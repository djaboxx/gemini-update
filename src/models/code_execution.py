"""
Models for code execution and results handling.

These models facilitate executing Python code generated by Gemini AI
and structuring the results for feedback and error correction.
"""

from typing import Dict, Any, Optional, List, Union
from enum import Enum
from datetime import datetime

from pydantic import BaseModel, Field, validator


class ExecutionStatus(str, Enum):
    """Status of code execution."""
    SUCCESS = "success"
    ERROR = "error"
    TIMEOUT = "timeout"
    INTERRUPTED = "interrupted"


class CodeExecutionError(BaseModel):
    """Representation of an error during code execution."""
    
    error_type: str = Field(..., description="Type of error (e.g., SyntaxError, TypeError)")
    message: str = Field(..., description="Error message")
    traceback: Optional[str] = Field(None, description="Full traceback if available")
    line_number: Optional[int] = Field(None, description="Line number where error occurred")
    column: Optional[int] = Field(None, description="Column where error occurred")
    
    def to_markdown(self) -> str:
        """Convert error to markdown format for display."""
        md = f"**{self.error_type}**: {self.message}\n\n"
        if self.line_number is not None:
            md += f"**Location**: Line {self.line_number}"
            if self.column is not None:
                md += f", Column {self.column}"
            md += "\n\n"
        
        if self.traceback:
            md += "**Traceback**:\n```\n"
            md += self.traceback
            md += "\n```\n"
            
        return md


class CodeExecutionResult(BaseModel):
    """Result of code execution."""
    
    status: ExecutionStatus = Field(..., description="Status of the execution")
    output: Optional[Any] = Field(None, description="Output of the code execution")
    errors: Optional[List[CodeExecutionError]] = Field(None, description="Errors that occurred during execution")
    execution_time: float = Field(..., description="Time taken for execution in seconds")
    timestamp: datetime = Field(default_factory=datetime.now, description="When the code was executed")
    memory_usage: Optional[float] = Field(None, description="Peak memory usage in MB if available")
    
    def to_markdown(self) -> str:
        """Convert result to markdown format for display."""
        md = f"# Code Execution Result\n\n"
        md += f"**Status**: {self.status.value}\n\n"
        md += f"**Execution Time**: {self.execution_time:.3f}s\n\n"
        
        if self.memory_usage is not None:
            md += f"**Memory Usage**: {self.memory_usage:.2f} MB\n\n"
        
        if self.status == ExecutionStatus.SUCCESS:
            md += "## Output\n\n"
            if isinstance(self.output, dict):
                md += "```json\n"
                import json
                md += json.dumps(self.output, indent=2, default=str)
                md += "\n```\n"
            else:
                md += f"```\n{self.output}\n```\n"
        
        elif self.errors:
            md += "## Errors\n\n"
            for error in self.errors:
                md += error.to_markdown()
                md += "\n"
        
        return md


class EnvVar(BaseModel):
    """Represents a single environment variable with a name and value."""
    model_config = {"extra": "forbid"}

    name: str = Field(..., description="The name of the environment variable.")
    value: str = Field(..., description="The value of the environment variable.")


class CodeExecutionRequest(BaseModel):
    """Request for code execution."""
    
    code: str = Field(..., description="Python code to execute")
    timeout_seconds: int = Field(default=10, description="Maximum execution time in seconds")
    description: str = Field(default="Code analysis", description="Description of what the code is doing")
    max_output_size: int = Field(default=100000, description="Maximum size of output to capture")
    environment_variables: Optional[List[EnvVar]] = Field(default=None, description="Environment variables to set")
    
    @validator('code')
    def code_must_not_be_empty(cls, v):
        """Validate that code is not empty."""
        if not v.strip():
            raise ValueError("Code cannot be empty")
        return v


class CodeSuggestion(BaseModel):
    """Suggested fix for code with errors."""
    
    original_code: str = Field(..., description="Original code with errors")
    suggested_code: str = Field(..., description="Suggested corrected code")
    explanation: str = Field(..., description="Explanation of the changes made")
    confidence: float = Field(..., description="Confidence in the suggestion (0.0 to 1.0)")
    
    def to_markdown(self) -> str:
        """Convert suggestion to markdown format for display."""
        md = f"# Code Suggestion\n\n"
        md += f"**Confidence**: {self.confidence * 100:.1f}%\n\n"
        md += f"**Explanation**: {self.explanation}\n\n"
        
        md += "## Original Code\n\n"
        md += "```python\n"
        md += self.original_code
        md += "\n```\n\n"
        
        md += "## Suggested Code\n\n"
        md += "```python\n"
        md += self.suggested_code
        md += "\n```\n"
        
        return md


class CodeFixRequest(BaseModel):
    """Request to fix code based on errors."""
    
    code: str = Field(..., description="Original code with errors")
    execution_result: CodeExecutionResult = Field(..., description="Result of executing the original code")
    fix_description: Optional[str] = Field(None, description="Description of what needs to be fixed")
    
    def to_prompt(self) -> str:
        """Convert to a prompt for the AI model."""
        prompt = f"Please fix the following Python code that has errors:\n\n"
        prompt += "```python\n"
        prompt += self.code
        prompt += "\n```\n\n"
        
        prompt += "Execution resulted in the following errors:\n\n"
        if self.execution_result.errors:
            for error in self.execution_result.errors:
                prompt += f"- {error.error_type}: {error.message}\n"
                if error.line_number:
                    prompt += f"  at line {error.line_number}\n"
                if error.traceback:
                    prompt += f"  Traceback: {error.traceback.split('Traceback')[-1].strip()}\n"
                    
        if self.fix_description:
            prompt += f"\nAdditional context: {self.fix_description}\n"
            
        prompt += "\nPlease provide a corrected version of the code that addresses these errors."
        return prompt
